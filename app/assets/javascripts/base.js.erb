/**
 * Function unhides logon action button and hides logoff button in
 * agent view.
 * 
 * @param {Object} queue - queue which buttons need to be toggled
 */
function toggle_action_item(queue, action, toggle){
    if(toggle != "on" && toggle != "off")
        return false;
    
    var $actionItem = $('tr[data-queue="' + queue + '"] td.action-col li[data-action="' + action + '"] a');
    $actionItem.html($actionItem.attr('data-' + toggle + '-label'));
    $actionItem.attr('href', $actionItem.attr('data-' + toggle + '-href'));
}

/**
 * Function unhides logoff button for specified queue and agent in 
 * actions menu in manager view.
 * 
 * @param {Object} queue
 * @param {Object} agent
 */
function add_queue_logoff_action(queue, agent){
    var $submenu = $('div.btn-group[data-agent="' + agent + '"] li[data-action="logoff"]');
    
    // Unhide logoff submenu if it is hidden
    if($submenu.hasClass("hidden")){
        $submenu.removeClass('hidden');
    }
    $submenu.find('a[data-queue="' + queue + '"]').parent().removeClass("hidden");
}

/**
 * Function hides logoff button for specified queue and agent in 
 * actions menu in manager view.
 * 
 * @param {Object} queue
 * @param {Object} agent
 */
function remove_queue_logoff_action(queue, agent){
    var $submenu = $('div.btn-group[data-agent="' + agent + '"] li[data-action="logoff"]');
    $submenu.find('a[data-queue="' + queue + '"]').parent().addClass("hidden");
    
    // hide logoff submenu if agent isn't logged to any of the queues
    if($submenu.find("li:not(.hidden)").length == 0){
        $submenu.addClass('hidden');
    }
}

/**
 * Function shows closable notice with specified message and notification
 * level on top of the page.
 * 
 * Available levels: error, info, success
 * 
 * @param {Object} msg - message to display
 * @param {Object} level
 */
function show_notice(msg, level){
    $notice = $('<div class="alert alert-block alert-' + level + '">');
    $notice.append('<button type="button" class="close" data-dismiss="alert">&times;</button>');
    $notice.append(msg);
    $('div#notices').append($notice);
}

/**
 * Function makes ajax request to refresh stats.
 */
function refresh_stats(){    
    var jqxhr =  $.get('<%= Rails.application.routes.url_helpers.refresh_stats_path %>').fail(function() { 
         console.log("Error trying to refresh stats.");
    });
}

/**
 * Function changes the innerHTML of given element with given value
 * and if new value is different than the old one, it highlights
 * the element.
 */
(function( $ ) {
  $.fn.change_and_highlight = function(val, options) {
    var settings = $.extend( {
      'color' : '#ffc40d',
      'timeout' : 3000
    }, options);
    
    if(this.html() != val)
        this.html(val).effect("highlight", {"color": options.color}, options.timeout);
  };
})( jQuery );

/**
 * Function fetches cookie value for the given name.
 */
function getCookie(c_name){
    var x,y,cookies=document.cookie.split(";");
    for (var i = 0; i < cookies.length; i++){
        name=cookies[i].substr(0,cookies[i].indexOf("="));
        value=cookies[i].substr(cookies[i].indexOf("=")+1);
        name=name.replace(/^\s+|\s+$/g,"");
        if (name==c_name){
            return unescape(value);
        }
    }
}

/**
 * Entry point
 */
$(document).ready(function(){
    // Connect to pbxis-ws
    if(getCookie("pbxis_ticket") != undefined)
        pbxis_connect(getCookie("pbxis_ticket"));
    
    if(getCookie("signed_in") != undefined){
        // Set stats refresh interval
        <% if Settings.pbxisws[:refresh_interval] > Rails.application.config.cache_store[2][:expires_in].value %>
            var timeout = <%= Settings.pbxisws[:refresh_interval]  %> * 1000;
        <% else %>
            var timeout = <%= Rails.application.config.cache_store[2][:expires_in].value  %> * 1000;
        <% end %>
        window.setInterval("refresh_stats()", timeout);
    }
    
    // Disable links in disabled menu items
    $('table').on('click', 'td.action-col li.disabled > a', function(evt){
        return false;
    });
});